---
name: skill-creator
description: 効果的なスキルを作成するためのガイド。ユーザーがClaudeの能力を専門知識、ワークフロー、またはツール統合で拡張する新しいスキルの作成（または既存スキルの更新）を希望する場合に使用するスキル。
---

# スキルクリエイター

このスキルは、効果的なスキルを作成するためのガイダンスを提供する。

## スキルについて

スキルは、専門知識、ワークフロー、ツールを提供することでClaudeの能力を拡張するモジュール型の自己完結パッケージである。特定のドメインやタスクのための「オンボーディングガイド」と考えると良い。汎用エージェントとしてのClaudeを、どのモデルも完全には持ち得ない手続き的知識を備えた専門エージェントへと変換する。

### スキルが提供するもの

1. 専門ワークフロー - 特定ドメインの多段階手順
2. ツール統合 - 特定のファイル形式やAPIを扱うための手順
3. ドメイン専門知識 - 企業固有の知識、スキーマ、ビジネスロジック
4. バンドルリソース - 複雑で反復的なタスクのためのスクリプト、リファレンス、アセット

## 基本原則

### 簡潔さが鍵

コンテキストウィンドウは公共財である。スキルは、Claudeが必要とする他のすべて（システムプロンプト、会話履歴、他のスキルのメタデータ、実際のユーザーリクエスト）とコンテキストウィンドウを共有する。

**デフォルトの前提：Claudeはすでに非常に賢い。** Claudeがまだ持っていないコンテキストのみを追加すること。各情報に対して「Claudeは本当にこの説明が必要か？」「この段落はトークンコストに見合うか？」と問いかけること。

冗長な説明よりも簡潔な例を優先すること。

### 適切な自由度を設定する

タスクの脆弱性と変動性に応じて具体性のレベルを合わせること：

**高い自由度（テキストベースの指示）**：複数のアプローチが有効な場合、判断がコンテキストに依存する場合、またはヒューリスティックがアプローチを導く場合に使用。

**中程度の自由度（擬似コードまたはパラメータ付きスクリプト）**：推奨パターンが存在する場合、多少のバリエーションが許容される場合、または設定が動作に影響する場合に使用。

**低い自由度（特定のスクリプト、少数のパラメータ）**：操作が脆弱でエラーが発生しやすい場合、一貫性が重要な場合、または特定の手順に従う必要がある場合に使用。

Claudeが道を探索していると考えること：崖のある狭い橋には具体的なガードレールが必要（低い自由度）で、開けた野原では多くのルートが可能（高い自由度）。

### スキルの構成

すべてのスキルは、必須のSKILL.mdファイルとオプションのバンドルリソースで構成される：

```
skill-name/
├── SKILL.md（必須）
│   ├── YAMLフロントマターメタデータ（必須）
│   │   ├── name:（必須）
│   │   ├── description:（必須）
│   │   └── compatibility:（オプション、ほとんど不要）
│   └── Markdownの指示（必須）
└── バンドルリソース（オプション）
    ├── scripts/          - 実行可能コード（Python/Bashなど）
    ├── references/       - 必要に応じてコンテキストに読み込まれるドキュメント
    └── assets/           - 出力に使用されるファイル（テンプレート、アイコン、フォントなど）
```

#### SKILL.md（必須）

すべてのSKILL.mdは以下で構成される：

- **フロントマター**（YAML）：`name`と`description`フィールド（必須）に加え、`license`、`metadata`、`compatibility`などのオプションフィールドを含む。Claudeがスキルのトリガータイミングを判断するために読むのは`name`と`description`のみであるため、スキルの内容と使用タイミングについて明確かつ包括的に記述すること。`compatibility`フィールドは環境要件（対象製品、システムパッケージなど）を記載するためのものだが、ほとんどのスキルでは不要。
- **本文**（Markdown）：スキルの使用に関する指示とガイダンス。スキルがトリガーされた後にのみ読み込まれる。

#### バンドルリソース（オプション）

##### スクリプト（`scripts/`）

決定論的な信頼性が必要な場合や繰り返し書き直されるタスクのための実行可能コード（Python/Bashなど）。

- **含めるタイミング**：同じコードが繰り返し書き直される場合、または決定論的な信頼性が必要な場合
- **例**：PDF回転タスク用の`scripts/rotate_pdf.py`
- **利点**：トークン効率が良く、決定論的で、コンテキストに読み込まずに実行可能
- **注意**：パッチや環境固有の調整のためにClaudeがスクリプトを読む必要がある場合もある

##### リファレンス（`references/`）

Claudeのプロセスと思考に情報を提供するために、必要に応じてコンテキストに読み込まれるドキュメントとリファレンス資料。

- **含めるタイミング**：Claudeが作業中に参照すべきドキュメントがある場合
- **例**：金融スキーマ用の`references/finance.md`、企業NDAテンプレート用の`references/mnda.md`、企業ポリシー用の`references/policies.md`、API仕様用の`references/api_docs.md`
- **ユースケース**：データベーススキーマ、APIドキュメント、ドメイン知識、企業ポリシー、詳細なワークフローガイド
- **利点**：SKILL.mdをスリムに保ち、Claudeが必要と判断した時のみ読み込まれる
- **ベストプラクティス**：ファイルが大きい場合（1万語以上）、SKILL.mdにgrep検索パターンを含めること
- **重複を避ける**：情報はSKILL.mdまたはリファレンスファイルのどちらかに存在すべきで、両方には置かない。スキルの核心でない限り、詳細情報にはリファレンスファイルを優先する。これによりSKILL.mdをスリムに保ちながら、コンテキストウィンドウを圧迫せずに情報を発見可能にする。SKILL.mdには必須の手続き的指示とワークフローガイダンスのみを残し、詳細なリファレンス資料、スキーマ、例はリファレンスファイルに移動すること。

##### アセット（`assets/`）

コンテキストに読み込むことを意図せず、Claudeが生成する出力内で使用されるファイル。

- **含めるタイミング**：最終出力で使用されるファイルがスキルに必要な場合
- **例**：ブランドアセット用の`assets/logo.png`、PowerPointテンプレート用の`assets/slides.pptx`、HTML/Reactボイラープレート用の`assets/frontend-template/`、タイポグラフィ用の`assets/font.ttf`
- **ユースケース**：テンプレート、画像、アイコン、ボイラープレートコード、フォント、コピーまたは修正されるサンプルドキュメント
- **利点**：出力リソースをドキュメントから分離し、Claudeがコンテキストに読み込まずにファイルを使用可能にする

#### スキルに含めるべきでないもの

スキルには、その機能を直接サポートする必須ファイルのみを含めるべきである。以下のような余計なドキュメントや補助ファイルを作成してはならない：

- README.md
- INSTALLATION_GUIDE.md
- QUICK_REFERENCE.md
- CHANGELOG.md
- など

スキルには、AIエージェントが目の前のジョブを実行するために必要な情報のみを含めるべきである。作成プロセスに関する補助的なコンテキスト、セットアップやテスト手順、ユーザー向けドキュメントなどは含めるべきではない。追加のドキュメントファイルを作成すると、混乱とノイズが増えるだけである。

### 段階的開示の設計原則

スキルは、コンテキストを効率的に管理するために3段階のローディングシステムを使用する：

1. **メタデータ（name + description）** - 常にコンテキスト内（約100語）
2. **SKILL.md本文** - スキルがトリガーされた時（5000語未満）
3. **バンドルリソース** - Claudeの必要に応じて（スクリプトはコンテキストウィンドウに読み込まずに実行可能なため無制限）

#### 段階的開示パターン

SKILL.md本文は必須事項に絞り、コンテキストの肥大化を最小限にするため500行以下に保つこと。この制限に近づいたら、コンテンツを別ファイルに分割すること。コンテンツを他のファイルに分割する際は、SKILL.mdからそれらを参照し、いつ読むべきかを明確に記述することが非常に重要である。これにより、スキルの読み手がファイルの存在と使用タイミングを把握できる。

**重要な原則：** スキルが複数のバリエーション、フレームワーク、またはオプションをサポートする場合、SKILL.mdにはコアワークフローと選択ガイダンスのみを残すこと。バリアント固有の詳細（パターン、例、設定）は別のリファレンスファイルに移動すること。

**パターン1：リファレンス付きハイレベルガイド**

```markdown
# PDF処理

## クイックスタート

pdfplumberでテキストを抽出：
[コード例]

## 高度な機能

- **フォーム入力**：完全なガイドは[FORMS.md](FORMS.md)を参照
- **APIリファレンス**：全メソッドは[REFERENCE.md](REFERENCE.md)を参照
- **例**：一般的なパターンは[EXAMPLES.md](EXAMPLES.md)を参照
```

Claudeは必要な時のみFORMS.md、REFERENCE.md、またはEXAMPLES.mdを読み込む。

**パターン2：ドメイン別の構成**

複数のドメインを持つスキルでは、関連のないコンテキストの読み込みを避けるためにドメイン別にコンテンツを整理する：

```
bigquery-skill/
├── SKILL.md（概要とナビゲーション）
└── reference/
    ├── finance.md（収益、課金指標）
    ├── sales.md（商談、パイプライン）
    ├── product.md（API使用状況、機能）
    └── marketing.md（キャンペーン、アトリビューション）
```

ユーザーが営業指標について質問した場合、Claudeはsales.mdのみを読む。

同様に、複数のフレームワークやバリアントをサポートするスキルでは、バリアント別に整理する：

```
cloud-deploy/
├── SKILL.md（ワークフロー + プロバイダー選択）
└── references/
    ├── aws.md（AWSデプロイパターン）
    ├── gcp.md（GCPデプロイパターン）
    └── azure.md（Azureデプロイパターン）
```

ユーザーがAWSを選択した場合、Claudeはaws.mdのみを読む。

**パターン3：条件付き詳細**

基本コンテンツを表示し、高度なコンテンツにリンクする：

```markdown
# DOCX処理

## ドキュメントの作成

新しいドキュメントにはdocx-jsを使用。[DOCX-JS.md](DOCX-JS.md)を参照。

## ドキュメントの編集

簡単な編集にはXMLを直接修正する。

**変更履歴の場合**：[REDLINING.md](REDLINING.md)を参照
**OOXMLの詳細**：[OOXML.md](OOXML.md)を参照
```

Claudeは、ユーザーがその機能を必要とする場合のみREDLINING.mdまたはOOXML.mdを読む。

**重要なガイドライン：**

- **深くネストされたリファレンスを避ける** - リファレンスはSKILL.mdから1階層の深さに保つこと。すべてのリファレンスファイルはSKILL.mdから直接リンクすること。
- **長いリファレンスファイルを構造化する** - 100行を超えるファイルには、Claudeがプレビュー時に全体像を把握できるよう、先頭に目次を含めること。

## スキル作成プロセス

スキル作成は以下の手順で行う：

1. 具体例でスキルを理解する
2. 再利用可能なスキルコンテンツを計画する（スクリプト、リファレンス、アセット）
3. スキルを初期化する（init_skill.pyを実行）
4. スキルを編集する（リソースを実装しSKILL.mdを記述）
5. スキルをパッケージ化する（package_skill.pyを実行）
6. 実際の使用に基づいて反復改善する

これらの手順を順番に実行すること。該当しない明確な理由がある場合のみスキップする。

### ステップ1：具体例でスキルを理解する

スキルの使用パターンがすでに明確に理解されている場合のみ、このステップをスキップする。既存のスキルを扱う場合でも、このステップは有用である。

効果的なスキルを作成するには、スキルがどのように使用されるかの具体例を明確に理解すること。この理解は、ユーザーからの直接的な例、またはユーザーフィードバックで検証された生成例から得ることができる。

例えば、image-editorスキルを構築する場合、関連する質問には以下が含まれる：

- 「image-editorスキルはどのような機能をサポートすべきですか？編集、回転、その他？」
- 「このスキルがどのように使われるか、いくつか例を教えてもらえますか？」
- 「ユーザーが『この画像の赤目を除去して』や『この画像を回転して』と言うことを想像できます。他にどのような使われ方を想像しますか？」
- 「このスキルをトリガーするために、ユーザーはどのように言いますか？」

ユーザーを圧倒しないよう、1つのメッセージで多くの質問をしすぎないこと。最も重要な質問から始め、必要に応じてフォローアップすること。

スキルがサポートすべき機能の明確な理解が得られたら、このステップを終了する。

### ステップ2：再利用可能なスキルコンテンツの計画

具体例を効果的なスキルに変換するため、各例を以下の観点で分析する：

1. ゼロから実行する方法を検討する
2. これらのワークフローを繰り返し実行する際に役立つスクリプト、リファレンス、アセットを特定する

例：「このPDFを回転するのを手伝って」のようなクエリを処理する`pdf-editor`スキルを構築する場合、分析結果は：

1. PDFの回転には毎回同じコードの書き直しが必要
2. `scripts/rotate_pdf.py`スクリプトをスキルに格納すると便利

例：「ToDoアプリを作って」や「歩数を追跡するダッシュボードを作って」のようなクエリに対する`frontend-webapp-builder`スキルを設計する場合、分析結果は：

1. フロントエンドウェブアプリの作成には毎回同じボイラープレートHTML/Reactが必要
2. ボイラープレートHTML/Reactプロジェクトファイルを含む`assets/hello-world/`テンプレートをスキルに格納すると便利

例：「今日ログインしたユーザーは何人？」のようなクエリを処理する`big-query`スキルを構築する場合、分析結果は：

1. BigQueryのクエリには毎回テーブルスキーマとリレーションシップの再発見が必要
2. テーブルスキーマを文書化した`references/schema.md`ファイルをスキルに格納すると便利

スキルのコンテンツを確定するため、各具体例を分析して含めるべき再利用可能なリソースのリストを作成する：スクリプト、リファレンス、アセット。

### ステップ3：スキルの初期化

この時点で、実際にスキルを作成する。

開発中のスキルがすでに存在し、反復やパッケージ化が必要な場合のみ、このステップをスキップする。その場合は次のステップに進む。

新しいスキルをゼロから作成する場合は、必ず`init_skill.py`スクリプトを実行すること。このスクリプトは、スキルが必要とするすべてを自動的に含む新しいテンプレートスキルディレクトリを便利に生成し、スキル作成プロセスをより効率的かつ信頼性の高いものにする。

使い方：

```bash
scripts/init_skill.py <skill-name> --path <output-directory>
```

スクリプトの動作：

- 指定されたパスにスキルディレクトリを作成
- 適切なフロントマターとTODOプレースホルダーを含むSKILL.mdテンプレートを生成
- サンプルリソースディレクトリを作成：`scripts/`、`references/`、`assets/`
- 各ディレクトリにカスタマイズまたは削除可能なサンプルファイルを追加

初期化後、生成されたSKILL.mdとサンプルファイルを必要に応じてカスタマイズまたは削除すること。

### ステップ4：スキルの編集

（新規生成または既存の）スキルを編集する際は、スキルが別のClaudeインスタンスが使用するために作成されていることを覚えておくこと。Claudeにとって有益で非自明な情報を含めること。別のClaudeインスタンスがこれらのタスクをより効果的に実行するのに役立つ手続き的知識、ドメイン固有の詳細、または再利用可能なアセットを検討すること。

#### 実証済みのデザインパターンを学ぶ

スキルのニーズに基づいて、これらの参考ガイドを参照すること：

- **多段階プロセス**：シーケンシャルワークフローと条件分岐についてはreferences/workflows.mdを参照
- **特定の出力形式や品質基準**：テンプレートと例のパターンについてはreferences/output-patterns.mdを参照

これらのファイルには、効果的なスキル設計のための確立されたベストプラクティスが含まれている。

#### 再利用可能なスキルコンテンツから始める

実装を開始するには、上記で特定した再利用可能なリソース（`scripts/`、`references/`、`assets/`ファイル）から始めること。このステップにはユーザー入力が必要な場合がある。例えば、`brand-guidelines`スキルを実装する際、ユーザーは`assets/`に格納するブランドアセットやテンプレート、または`references/`に格納するドキュメントを提供する必要がある場合がある。

追加したスクリプトは、バグがなく出力が期待通りであることを確認するために、実際に実行してテストする必要がある。類似のスクリプトが多い場合は、完了までの時間とのバランスを取りながら、すべてが動作するという確信を得るために代表的なサンプルのみをテストすればよい。

スキルに不要なサンプルファイルとディレクトリは削除すること。初期化スクリプトは構造を示すために`scripts/`、`references/`、`assets/`にサンプルファイルを作成するが、ほとんどのスキルではすべてを必要としない。

#### SKILL.mdの更新

**記述ガイドライン：** 常に命令形/不定詞形を使用すること。

##### フロントマター

`name`と`description`を含むYAMLフロントマターを記述する：

- `name`：スキル名
- `description`：スキルの主要なトリガーメカニズムであり、Claudeがスキルの使用タイミングを理解するのに役立つ。
  - スキルの内容と、使用すべき具体的なトリガー/コンテキストの両方を含めること。
  - すべての「使用タイミング」情報はここに記載する - 本文には記載しない。本文はトリガー後にのみ読み込まれるため、本文の「このスキルを使用するタイミング」セクションはClaudeにとって役立たない。
  - `docx`スキルのdescription例：「変更履歴、コメント、書式保持、テキスト抽出をサポートする包括的なドキュメント作成、編集、分析。Claudeがプロフェッショナルドキュメント（.docxファイル）を扱う必要がある場合に使用：(1) 新規ドキュメント作成、(2) コンテンツの修正または編集、(3) 変更履歴の操作、(4) コメントの追加、その他あらゆるドキュメントタスク」

YAMLフロントマターに他のフィールドを含めないこと。

##### 本文

スキルとバンドルリソースの使用に関する指示を記述する。

### ステップ5：スキルのパッケージ化

スキルの開発が完了したら、ユーザーと共有する配布可能な.skillファイルにパッケージ化する必要がある。パッケージ化プロセスは、すべての要件を満たしていることを確認するため、まず自動的にスキルを検証する：

```bash
scripts/package_skill.py <path/to/skill-folder>
```

オプションの出力ディレクトリ指定：

```bash
scripts/package_skill.py <path/to/skill-folder> ./dist
```

パッケージ化スクリプトの動作：

1. スキルを自動的に**検証**し、以下をチェック：

   - YAMLフロントマターの形式と必須フィールド
   - スキルの命名規則とディレクトリ構造
   - descriptionの完全性と品質
   - ファイル構成とリソース参照

2. 検証が通れば、スキルを**パッケージ化**し、スキル名にちなんだ.skillファイル（例：`my-skill.skill`）を作成する。このファイルにはすべてのファイルが含まれ、配布用の適切なディレクトリ構造を維持する。.skillファイルは.skill拡張子を持つzipファイルである。

検証が失敗した場合、スクリプトはエラーを報告し、パッケージを作成せずに終了する。検証エラーを修正し、パッケージ化コマンドを再度実行すること。

### ステップ6：反復改善

スキルをテストした後、ユーザーが改善を求めることがある。これはスキルの使用直後、スキルのパフォーマンスについてのフレッシュなコンテキストがある状態で起こることが多い。

**反復ワークフロー：**

1. 実際のタスクでスキルを使用する
2. 苦労や非効率を見つける
3. SKILL.mdやバンドルリソースをどう更新すべきか特定する
4. 変更を実装し、再度テストする
